// 简化版本 - 只启用 USB CDC-ACM
// 用于 Windows 调试
// 
// 使用方法：
// 1. 将此文件重命名为 main.rs（备份原文件）
// 2. cargo build --release
// 3. 烧录并测试

#![no_std]
#![no_main]

mod banner;
mod config;
mod logger;
mod tasks;
mod usb;

use defmt::*;
use embassy_executor::Spawner;
use embassy_rp::bind_interrupts;
use embassy_rp::multicore::{spawn_core1, Stack};
use embassy_rp::peripherals::{UART0, USB};
use embassy_rp::uart::{Config, InterruptHandler as UartInterruptHandler, Uart};
use embassy_rp::usb::InterruptHandler as UsbInterruptHandler;
use static_cell::StaticCell;
use {defmt_rtt as _, panic_probe as _};

use banner::send_banner;
use config::{uart, CORE1_STACK_SIZE};
use logger::uart_task;
use tasks::{core0_task, core1_task};

bind_interrupts!(struct Irqs {
    UART0_IRQ => UartInterruptHandler<UART0>;
    USBCTRL_IRQ => UsbInterruptHandler<USB>;
});

static mut CORE1_STACK: Stack<CORE1_STACK_SIZE> = Stack::new();
static EXECUTOR1: StaticCell<embassy_executor::Executor> = StaticCell::new();

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    // 初始化硬件
    let p = embassy_rp::init(Default::default());

    info!("Hardware initialized");

    // 配置 UART0 - 用于日志输出
    let mut config = Config::default();
    config.baudrate = uart::BAUD_RATE;
    let uart = Uart::new(
        p.UART0,
        p.PIN_0,
        p.PIN_1,
        Irqs,
        p.DMA_CH0,
        p.DMA_CH1,
        config,
    );

    info!("UART0 configured");

    // 首先启动 UART 日志任务
    spawner.spawn(uart_task(uart)).unwrap();

    // 等待 UART 任务启动
    embassy_time::Timer::after_millis(10).await;

    // 发送启动横幅
    send_banner().await;

    log_info!("Main", "=== SIMPLE USB VERSION ===");
    log_info!("Main", "System initialization starting...");

    // 初始化简化的 USB（仅 CDC-ACM）
    log_info!("Main", "Initializing USB CDC-ACM only...");
    spawner.spawn(usb_simple_task(p.USB)).unwrap();
    
    log_info!("Main", "USB CDC-ACM task spawned");

    // 启动 Core 0 任务
    log_info!("Main", "Spawning Core 0 task");
    spawner.spawn(core0_task()).unwrap();

    // 启动 Core 1
    log_info!("Main", "Spawning Core 1");
    #[allow(static_mut_refs)]
    spawn_core1(p.CORE1, unsafe { &mut CORE1_STACK }, move || {
        let executor1 = EXECUTOR1.init(embassy_executor::Executor::new());
        info!("Core 1 executor initialized");
        executor1.run(|spawner| {
            spawner.spawn(core1_task()).unwrap();
        });
    });

    // 等待所有任务启动
    embassy_time::Timer::after_millis(100).await;

    log_info!("Main", "====================================");
    log_info!("Main", "System startup complete!");
    log_info!("Main", "- UART0: GPIO0(TX) / GPIO1(RX)");
    log_info!("Main", "- USB: CDC-ACM Serial ONLY");
    log_info!("Main", "- Dual Core: Core0 + Core1 running");
    log_info!("Main", "====================================");
    log_info!("Main", "");
    log_info!("Main", "NOTE: This is a simplified version");
    log_info!("Main", "Only USB Serial (CDC-ACM) is enabled");
    log_info!("Main", "HID devices are disabled for debugging");
}

/// 简化的 USB 任务 - 仅 CDC-ACM
#[embassy_executor::task]
async fn usb_simple_task(usb_periph: USB) {
    // 等待一下让日志系统稳定
    embassy_time::Timer::after_millis(50).await;
    
    log_info_sync!("USB", "Simple USB task started (CDC-ACM only)");
    info!("USB: Initializing CDC-ACM driver");
    
    // 初始化 USB 驱动
    let driver = embassy_rp::usb::Driver::new(usb_periph, Irqs);
    log_info_sync!("USB", "USB driver created");
    
    // 创建简化的配置
    let mut config = embassy_usb::Config::new(0x2e8a, 0x000a);
    config.manufacturer = Some("RP1 Embassy");
    config.product = Some("CDC-ACM Serial");
    config.serial_number = Some("12345678");
    config.max_power = 100; // 200mA
    config.max_packet_size_0 = 64;
    
    // 不设置为复合设备，单一 CDC-ACM 类
    config.device_class = 0x02; // CDC
    config.device_sub_class = 0x00;
    config.device_protocol = 0x00;
    
    log_info_sync!("USB", "USB config created (VID:0x2E8A PID:0x000A)");
    log_info_sync!("USB", "Single CDC-ACM class device");
    
    // 创建构建器
    static CONFIG_DESC: StaticCell<[u8; 256]> = StaticCell::new();
    static BOS_DESC: StaticCell<[u8; 256]> = StaticCell::new();
    static MSOS_DESC: StaticCell<[u8; 256]> = StaticCell::new();
    static CTRL_BUF: StaticCell<[u8; 128]> = StaticCell::new();
    
    let mut builder = embassy_usb::Builder::new(
        driver,
        config,
        CONFIG_DESC.init([0; 256]),
        BOS_DESC.init([0; 256]),
        MSOS_DESC.init([0; 256]),
        CTRL_BUF.init([0; 128]),
    );
    log_info_sync!("USB", "USB builder created");
    
    // 只创建 USB 串口 (CDC-ACM)
    static CDC_STATE: StaticCell<embassy_usb::class::cdc_acm::State> = StaticCell::new();
    let cdc_state = CDC_STATE.init(embassy_usb::class::cdc_acm::State::new());
    let cdc_acm = usb::serial::create_cdc_acm(&mut builder, cdc_state);
    log_info_sync!("USB", "CDC-ACM serial port created");
    
    // 构建 USB 设备
    let mut usb_device = builder.build();
    log_info_sync!("USB", "USB device built successfully");
    log_info_sync!("USB", "Waiting for USB enumeration...");
    log_info_sync!("USB", "Device should appear as COM port in Windows");
    info!("USB: Device ready, starting main loop");
    
    // 运行 USB 设备和 CDC-ACM
    let usb_fut = usb_device.run();
    let cdc_fut = usb::serial::run_cdc_acm(cdc_acm);
    
    log_info_sync!("USB", "USB tasks starting...");
    
    embassy_futures::join::join(usb_fut, cdc_fut).await;
    
    log_error_sync!("USB", "USB tasks exited unexpectedly!");
}

